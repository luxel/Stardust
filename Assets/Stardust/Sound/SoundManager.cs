namespace Stardust
{
    using UnityEngine;
    using System.Collections;
    using System.Collections.Generic;

    /// <summary>
    /// When the sound should be played.
    /// </summary>
    public enum SoundPlayMode
    {
        /// <summary>
        /// The sound will be played immediately
        /// </summary>
        Instant,
        /// <summary>
        /// The sound will be queued with other sounds with the same priority
        /// </summary>
        Queued
    }

    /// <summary>
    /// Sound channel selection strategy.
    /// </summary>
    public enum SoundChannelStrategy
    {
        /// <summary>
        /// Search for same priority channel first, then search channels with lower priority.
        /// </summary>
        SamePriorityFirst,
        /// <summary>
        /// Search for empty channel first, then search lower priority channel.
        /// </summary>
        EmptyOrLowerPriority
    }

    /// <summary>
    /// Complete information for playing a sound.
    /// </summary>
    public class SoundPlayInfo
    {
        /// <summary>
        /// Unique sequence id generated by SoundManager.
        /// </summary>
        public int AudioId;
        /// <summary>
        /// User defined priority number starting from zero.
        /// </summary>
        public int Priority;
        /// <summary>
        /// Name of the sound.
        /// </summary>
        public string Name;
        /// <summary>
        /// The audio clip to be played.
        /// </summary>
        public AudioClip Clip;
        /// <summary>
        /// The mode to play the sound.
        /// </summary>
        public SoundPlayMode Mode;
        /// <summary>
        /// The strategy to search available sound channels.
        /// </summary>
        public SoundChannelStrategy Strategy;
        /// <summary>
        /// Whether this sound can be interrupted during play.
        /// </summary>
        public bool Interruptable = true;
        /// <summary>
        /// Whether this soudn should persist during scene switching.
        /// </summary>
        public bool Persist;
        /// <summary>
        /// Whether this sound should be looped.
        /// </summary>
        public bool Loop;
        public float MinDistance;
        public float MaxDistance;
        public float Volume;
        /// <summary>
        /// Source position of the sound.
        /// </summary>
        public Vector3 SourcePosition;
        /// <summary>
        /// Sound play pitch
        /// </summary>
        public float Pitch;
        /// <summary>
        /// Sound fade in (seconds)
        /// </summary>
        public float FadeInSeconds = 0f;
        /// <summary>
        /// Sound fade out (seconds)
        /// </summary>
        public float FadeOutSeconds = 0f;
        /// <summary>
        /// Whether the sound should fade in when starting play.
        /// </summary>
        public bool NeedFadeIn
        {
            get { return FadeInSeconds > 0f; }
        }
        /// <summary>
        /// Whether the sound should fade out when stopping.
        /// </summary>
        public bool NeedFadeOut
        {
            get { return FadeOutSeconds > 0f; }
        }
    }

    /// <summary>
    /// Global manager for all sounds. Containing multiple channels for sound replay.
    /// </summary>
    public class SoundManager : MonoBehaviour
    {
        #region Singleton instance
        private static SoundManager _Instance = null;

        private static SoundManager Instance
        {
            get
            {
                if (_Instance == null)
                {
                    // Create gameObject and add component
                    _Instance = (new GameObject("[SoundManager]")).AddComponent<SoundManager>();
                }
                return _Instance;
            }
        }
        #endregion

        /// <summary>
        /// The gameobject that the sound manager is attached to
        /// </summary>
        public static GameObject Gameobject { get { return Instance.gameObject; } }

        /// <summary>
        /// Attaches the sound player to the target transform (normally, the main camera)
        /// </summary>
        /// <param name="transform"></param>
        public static void AttachToTransform(Transform transform)
        {
            Instance.transform.parent = transform;
            Instance.transform.localPosition = Vector3.zero;
        }

        /// <summary>
        /// Releases the sound player from parent transform.
        /// </summary>
        public static void ReleaseFromParent()
        {
            if (_Instance != null)
            {
                _Instance.transform.parent = null;
            }
        }
        /// <summary>
        /// Plays the specified sound info.
        /// </summary>
        /// <returns>Audio Id of the sound info.</returns>
        public static int PlaySoundStatic(SoundPlayInfo info)
        {
            return Instance.PlaySound(info);
        }

        /// <summary>
        /// Stops all current playing sounds, except the excluding priorities.
        /// </summary>
        /// <param name="excludingPriorities">Channel priorities to be excluded.</param>
        public static void StopAllSounds(params int[] excludingPriorities)
        {
            Instance.StopAll(excludingPriorities);
        }
        /// <summary>
        /// Stops a sound with specified audio id.
        /// </summary>
        public static void StopSound(int audioId)
        {
            var channel = Instance.GetAudioChannel(audioId);
            if (channel != null)
            {
                channel.Stop();
            }
        }
        /// <summary>
        /// Checks whether sound with the specified audio id is playing.
        /// </summary>
        /// <param name="audioId">Audio id of the sound.</param>
        /// <param name="includeQueued">Whether we should check queued sounds.</param>
        /// <returns>True if the sound is being played or queued.</returns>
        public static bool IsSoundPlaying(int audioId, bool includeQueued = false)
        {
            var channel = Instance.GetAudioChannel(audioId, includeQueued);
            if (channel != null)
            {
                return true;
            }
            else
            {
                return false;
            }
        }
        /// <summary>
        /// Adjust the pitch of the specific audio id.
        /// </summary>
        public static void SetSoundPlaySpeed(int audioId, float pitch)
        {
            var channel = Instance.GetAudioChannel(audioId);
            if (channel != null)
            {
                channel.UpdatePitch(pitch);
            }
        }
        /// <summary>
        /// Gets audio channel with specified audio id.
        /// </summary>
        public static SoundChannel GetAudioChannelStatic(int audioId)
        {
            return Instance.GetAudioChannel(audioId);
        }
        /// <summary>
        /// Count of sound channels.
        /// </summary>
        private static int SoundChannelsCount = 15;
        /// <summary>
        /// Initial id.
        /// </summary>
        private const int InitialIdSeed = 0;
        /// <summary>
        /// Seed of audio ids.
        /// </summary>
        private static int AudioIdSeed = InitialIdSeed;

        private bool m_initialized = false;

        private List<SoundChannel> m_channels;

        void Awake()
        {
            Init();
        }

        void OnDestroy()
        {
            UnityEngine.SceneManagement.SceneManager.activeSceneChanged -= SceneManager_activeSceneChanged;
            _Instance = null;
        }

        void Init()
        {
            if (!m_initialized)
            {
                m_channels = new List<SoundChannel>();
                for (int i = 0; i < SoundChannelsCount; i++)
                {
                    var go = new GameObject(string.Format("channel_{0:D2}", (i + 1)));
                    go.transform.parent = this.transform;
                    go.transform.localPosition = Vector3.zero;
                    var source = go.AddComponent<AudioSource>();

                    m_channels.Add(new SoundChannel(source));
                }
                UnityEngine.SceneManagement.SceneManager.activeSceneChanged += SceneManager_activeSceneChanged;
                DontDestroyOnLoad(this.gameObject);
                m_initialized = true;
            }
        }

        private void SceneManager_activeSceneChanged(UnityEngine.SceneManagement.Scene arg0, UnityEngine.SceneManagement.Scene arg1)
        {
            ReleaseFromParent();
            for (int i = 0; i < m_channels.Count; i++)
            {
                var channel = m_channels[i];
                if (!channel.Persist)
                {
                    channel.Stop();
                }
            }
        }

        public int PlaySound(SoundPlayInfo info)
        {
            if (string.IsNullOrEmpty(info.Name))
            {
#if UNITY_EDITOR
                Debug.LogError("Audio name is empty!");
#endif
                return -1;
            }
            if (info.Clip == null)
            {
#if UNITY_EDITOR
                Debug.LogWarningFormat("No audio clip is provided for sound {0}", info.Name);
#endif
                return -1;
            }
            info.AudioId = GetNewId();
            if (info.SourcePosition == Vector3.zero)
            {
                info.SourcePosition = Gameobject.transform.position;
            }
            SoundChannel channel = FindChannel(info.Priority, info.Strategy);
            if (channel != null)
            {
                channel.PlayClip(info);
            }
            else
            {
                //Debug.LogWarningFormat("Unable to find avaiable sound channel for audio {0}", info.Name);
            }
            return info.AudioId;
        }

        public void StopAll(params int[] excludingPriorities)
        {
            for (int i = 0; i < m_channels.Count; i++)
            {
                var channel = m_channels[i];
                bool excluded = false;
                for (int p = 0; p < excludingPriorities.Length; p++)
                {
                    if (channel.Priority == excludingPriorities[p])
                    {
                        excluded = true;
                        break;
                    }
                }
                if (!excluded)
                {
                    channel.Stop();
                }
            }
        }

        public SoundChannel GetAudioChannel(int audioId, bool includingQueued = false)
        {
            if (audioId <= InitialIdSeed)
            {
                return null;
            }
            for (int i = 0; i < m_channels.Count; i++)
            {
                SoundChannel channel = m_channels[i];
                if (channel.audioID == audioId)
                {
                    return channel;
                }
                if (includingQueued && channel.IsSoundQueued(audioId))
                {
                    return channel;
                }
            }
            return null;
        }

        // Update is called once per frame
        void Update()
        {
            for (int i = 0; i < m_channels.Count; i++)
            {
                SoundChannel channel = m_channels[i];
                channel.Update();
            }
        }

        private int GetNewId()
        {
            return ++AudioIdSeed;
        }

        private SoundChannel FindChannel(int priority, SoundChannelStrategy strategy)
        {
            if (strategy == SoundChannelStrategy.SamePriorityFirst)
            {
                for (int i = 0; i < m_channels.Count; i++)
                {
                    SoundChannel ch = m_channels[i];
                    if (ch.Priority == priority)
                    {
                        return ch;
                    }
                }
            }

            SoundChannel oldestInterruptable = null;
            SoundChannel oldestNonInterruptable = null;
            for (int i = 0; i < m_channels.Count; i++)
            {
                SoundChannel ch = m_channels[i];
                if (ch.IsEmpty)
                {
                    return ch;
                }

                bool interruptable = ch.Priority <= priority && ch.Interruptable;
                if (interruptable && (oldestInterruptable == null || oldestInterruptable.TimeStartedPlaying > ch.TimeStartedPlaying))
                {
                    oldestInterruptable = ch;
                }

                bool nonInterruptable = ch.Priority <= priority && !ch.Interruptable;
                if (nonInterruptable && (oldestNonInterruptable == null || oldestNonInterruptable.TimeStartedPlaying > ch.TimeStartedPlaying))
                {
                    oldestNonInterruptable = ch;
                }
            }

            if (oldestInterruptable != null)
            {
                return oldestInterruptable;
            }
            else
            {
                return oldestNonInterruptable;
            }
        }
    } 
}